import { describe, it } from 'node:test'
import assert from 'node:assert/strict'
import { defaultXMLTags, nano2xml } from "./index.js"

describe("nano2xml", () => {
	it('simple object', () => {
		const data = { $id: "1", note: "Hello" }
		const xml = nano2xml(data, { indent: '  ', newLine: '\n' })
		const expected = '<note id="1">Hello</note>'
		assert.equal(xml.trim(), expected)
	})

	it('with array and default tag', () => {
		const data = [{ item: 'A' }, { item: 'B' }]
		const xml = nano2xml(data, {
			indent: '',
			newLine: '',
			defaultTags: { '': 'item' }
		})
		const expected = '<item>A</item><item>B</item>'
		assert.equal(xml, expected)
	})

	it('selfâ€‘closed handling', () => {
		const data = { img: true, $src: 'pic.png' }
		const xml = nano2xml(data, {
			defaultTags: {
				$selfClosed: (tag) => tag === 'img' && true,
				$attrCase: 'kebab'
			}
		})
		const expected = '<img src="pic.png" />'
		assert.equal(xml.trim(), expected)
	})

	it('should handle attributes', () => {
		const data = { root: { $attr: 'value', $ariaLabel: 'element' } }
		const expectedXml = '<root>\n\t<element attr="value" aria-label="element" />\n</root>'
		const xml = nano2xml(data, { indent: '\t', newLine: '\n', defaultTags: { ...defaultXMLTags, $selfClosed: true } })
		assert.equal(xml, expectedXml)
	})

	it('should skip undefined attributes', () => {
		const data = { root: { $attr: 'value', $ariaLabel: 'element', $id: undefined } }
		const expectedXml = '<root>\n\t<element attr="value" aria-label="element" />\n</root>'
		const xml = nano2xml(data, { indent: '\t', newLine: '\n', defaultTags: { ...defaultXMLTags, $selfClosed: true } })
		assert.equal(xml, expectedXml)
	})

	it('should handle attributes with snake case', () => {
		const data = { root: { $attr: 'value', $ariaLabel: 'element' } }
		const expectedXml = '<root>\n\t<element attr="value" aria_label="element" />\n</root>'
		const xml = nano2xml(data, { indent: '\t', newLine: '\n', defaultTags: { ...defaultXMLTags, $selfClosed: true, $attrCase: 'snake' } })
		assert.equal(xml, expectedXml)
	})

	it('should handle attributes with camel case', () => {
		const data = { root: { $attr: 'value', $ariaLabel: 'element' } }
		const expectedXml = '<root>\n\t<element attr="value" ariaLabel="element" />\n</root>'
		const xml = nano2xml(data, { indent: '\t', newLine: '\n', defaultTags: { ...defaultXMLTags, $selfClosed: true, $attrCase: 'camel' } })
		assert.equal(xml, expectedXml)
	})

	it('should handle comments', () => {
		const data = { root: true, '#comment': 'This is a comment' }
		const expectedXml = '<!-- comment: This is a comment -->\n<root></root>'
		const xml = nano2xml(data, { indent: '\t', newLine: '\n', defaultTags: defaultXMLTags })
		assert.equal(xml, expectedXml)
	})

	it('should render proper sitemap index XML', () => {
		const data = [
			{ $version: '1.0', $encoding: 'UTF-8', '?xml': true },
			{ $type: 'text/xsl', $href: '//yaro.page/test.xsl', '?xml-stylesheet': true },
			{
				$xmlns: 'http://www.sitemaps.org/schemas/sitemap/0.9',
				sitemapindex: [
					{
						sitemap: [
							{ loc: 'http://yaro.page/post-sitemap.xml' },
							{ lastmod: '2024-12-28T10:50:59+00:00' }
						]
					}
				]
			},
			{ '#XML Sitemap': 'generated by nano.js templates' },
		]
		const expected = `<?xml version="1.0" encoding="UTF-8"?>\n<?xml-stylesheet type="text/xsl" href="//yaro.page/test.xsl"?>\n<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n\t<sitemap>\n\t\t<loc>http://yaro.page/post-sitemap.xml</loc>\n\t\t<lastmod>2024-12-28T10:50:59+00:00</lastmod>\n\t</sitemap>\n</sitemapindex>\n<!-- XML Sitemap: generated by nano.js templates -->`
		const xml = nano2xml(data, { defaultTags: defaultXMLTags, indent: '\t', newLine: '\n' })
		assert.equal(xml, expected)
	})

	it('should correctly render self-closed tags like img, input, br, hr', () => {
		const data = {
			container: {
				img: true,
				input: true,
				br: true,
				hr: true
			}
		}
		const xml = nano2xml(data, {
			indent: '\t',
			newLine: '\n',
			defaultTags: {
				$selfClosed: (tag) => ['img', 'input', 'br', 'hr'].includes(tag)
			}
		})
		const expected = `<container>\n\t<img />\n\t<input />\n\t<br />\n\t<hr />\n</container>`
		assert.equal(xml, expected)
	})

	it('should correctly handle empty content with self-closing logic', () => {
		const data = { br: '' }
		const defaultTags = { $selfClosed: true }
		const xml = nano2xml(data, { defaultTags })
		assert.equal(xml, '<br />')
	})

	it('should correctly render self-closed tags with attributes', () => {
		const data = [
			{ img: true, $src: 'image.png', $alt: 'An Image' },
			{ input: true, $type: 'text', $name: 'username' }
		]
		const xml = nano2xml(data, {
			indent: '\t',
			newLine: '\n',
			defaultTags: {
				$selfClosed: (tag) => ['img', 'input'].includes(tag)
			}
		})
		const expected = `<img src="image.png" alt="An Image" />\n<input type="text" name="username" />`
		assert.equal(xml, expected)
	})

	it("should render inline script and style tags correctly?", async () => {
		//import { HTMLTransformer } from '@nan0web/html'
		const data = [
			{ script: 'console.log("hello");' },
			{ style: '.my-class { color: red; }' },
		]

		const html = nano2xml(data, {
			newLine: "",
			defaultTags: { $cdataTags: ['script', 'style'] }
		})
		assert.equal(
			html,
			'<script><![CDATA[console.log("hello");]]></script><style><![CDATA[.my-class { color: red; }]]></style>'
		)
	})
})
